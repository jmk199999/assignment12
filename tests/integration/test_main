import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from datetime import datetime, timezone
from uuid import UUID

# Import your application's components
from app.main import app, get_db, Base
from app.schemas.user import UserResponse
from app.auth.dependencies import get_current_active_user

# --- In-memory database setup for testing ---
SQLALCHEMY_DATABASE_URL = "sqlite:///:memory:"

engine = create_engine(
    SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False}
)
TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)


# Override the dependency to use the test database
@pytest.fixture(scope="session")
def db_session_fixture():
    # Create the tables once for the entire test session
    Base.metadata.create_all(bind=engine)
    db = TestingSessionLocal()
    try:
        yield db
    finally:
        db.close()
        # Drop the tables after the test session is complete
        Base.metadata.drop_all(bind=engine)

@pytest.fixture(scope="function", autouse=True)
def override_get_db(db_session_fixture):
    """
    Fixture to provide a clean database session for each test function.
    """
    def override():
        db = TestingSessionLocal()
        try:
            yield db
        finally:
            db.close()
    
    app.dependency_overrides[get_db] = override
    # Clean the database before each test
    for table in reversed(Base.metadata.sorted_tables):
        db_session_fixture.execute(table.delete())
    db_session_fixture.commit()
    return db_session_fixture


# Override the authentication dependency to return a mock user
TEST_USER_ID = UUID("a2b1c0d3-e4f5-6789-abcd-ef0123456789")
TEST_USER_DICT = {
    "id": str(TEST_USER_ID),
    "username": "testuser",
    "email": "test@example.com",
    "first_name": "Test",
    "last_name": "User",
    "is_active": True,
    "is_verified": True,
    "created_at": datetime.now(timezone.utc).isoformat(),
    "updated_at": datetime.now(timezone.utc).isoformat(),
}
TEST_USER_RESPONSE = UserResponse(**TEST_USER_DICT)


@pytest.fixture(autouse=True)
def override_auth_dependency():
    app.dependency_overrides[get_current_active_user] = lambda: TEST_USER_RESPONSE


client = TestClient(app)

# --- Test Cases ---

def test_health_check():
    response = client.get("/health")
    assert response.status_code == 200
    assert response.json() == {"status": "ok"}


# --- User Registration Tests ---
def test_register_user_success():
    user_data = {
        "username": "newuser",
        "email": "newuser@example.com",
        "password": "strongpassword123",
        "confirm_password": "strongpassword123",
        "first_name": "New",
        "last_name": "User"
    }
    response = client.post("/auth/register", json=user_data)
    assert response.status_code == 201
    assert response.json()["username"] == "newuser"
    assert "id" in response.json()


def test_register_user_password_mismatch():
    user_data = {
        "username": "mismatch",
        "email": "mismatch@example.com",
        "password": "password123",
        "confirm_password": "password124",
        "first_name": "Mismatch",
        "last_name": "User",
    }
    response = client.post("/auth/register", json=user_data)
    assert response.status_code == 400
    assert "Passwords do not match" in response.json()["detail"]


# --- User Login Tests ---
def test_login_json_success():
    # First, register a user
    user_data = {
        "username": "loginuser",
        "email": "login@example.com",
        "password": "password123",
        "confirm_password": "password123",
    }
    client.post("/auth/register", json=user_data)

    # Now, try to log in
    login_data = {"username": "loginuser", "password": "password123"}
    response = client.post("/auth/login", json=login_data)
    assert response.status_code == 200
    assert "access_token" in response.json()
    assert "refresh_token" in response.json()


def test_login_json_invalid_credentials():
    login_data = {"username": "nonexistent", "password": "wrongpassword"}
    response = client.post("/auth/login", json=login_data)
    assert response.status_code == 401
    assert "Invalid username or password" in response.json()["detail"]


# --- Calculation Endpoints Tests ---

def test_create_calculation_success():
    calculation_data = {
        "type": "addition",
        "inputs": [1, 2, 3],
    }
    response = client.post("/calculations", json=calculation_data)
    assert response.status_code == 201
    assert response.json()["type"] == "addition"
    assert response.json()["inputs"] == [1, 2, 3]
    assert response.json()["result"] == 6
    assert response.json()["user_id"] == str(TEST_USER_ID)


def test_create_calculation_invalid_type():
    calculation_data = {
        "type": "invalid_operation",
        "inputs": [1, 2],
    }
    response = client.post("/calculations", json=calculation_data)
    assert response.status_code == 400
    assert "Invalid calculation type" in response.json()["detail"]


def test_list_calculations_success():
    # Create a calculation for the test user
    client.post("/calculations", json={"type": "addition", "inputs": [1, 1]})
    client.post("/calculations", json={"type": "subtraction", "inputs": [10, 5]})

    # Now, list all calculations for the current user
    response = client.get("/calculations")
    assert response.status_code == 200
    assert len(response.json()) == 2
    assert response.json()[0]["type"] == "addition"


def test_get_calculation_success():
    # Create a calculation to get its ID
    response = client.post("/calculations", json={"type": "addition", "inputs": [5, 5]})
    calc_id = response.json()["id"]

    # Now, retrieve that calculation by its ID
    get_response = client.get(f"/calculations/{calc_id}")
    assert get_response.status_code == 200
    assert get_response.json()["id"] == calc_id
    assert get_response.json()["result"] == 10


def test_get_calculation_not_found():
    response = client.get("/calculations/f0f0f0f0-f0f0-f0f0-f0f0-f0f0f0f0f0f0")
    assert response.status_code == 404
    assert "Calculation not found" in response.json()["detail"]


def test_get_calculation_invalid_id():
    response = client.get("/calculations/invalid-uuid-string")
    assert response.status_code == 400
    assert "Invalid calculation id format." in response.json()["detail"]


def test_update_calculation_success():
    # Create a calculation
    response = client.post("/calculations", json={"type": "addition", "inputs": [1, 1]})
    calc_id = response.json()["id"]

    # Update the calculation
    update_data = {"inputs": [10, 20]}
    update_response = client.put(f"/calculations/{calc_id}", json=update_data)
    assert update_response.status_code == 200
    assert update_response.json()["id"] == calc_id
    assert update_response.json()["inputs"] == [10, 20]
    assert update_response.json()["result"] == 30


def test_update_calculation_not_found():
    update_data = {"inputs": [1, 2]}
    response = client.put("/calculations/f0f0f0f0-f0f0-f0f0-f0f0-f0f0f0f0f0f0", json=update_data)
    assert response.status_code == 404
    assert "Calculation not found" in response.json()["detail"]


def test_delete_calculation_success():
    # Create a calculation to be deleted
    response = client.post("/calculations", json={"type": "addition", "inputs": [1, 1]})
    calc_id = response.json()["id"]

    # Delete the calculation
    delete_response = client.delete(f"/calculations/{calc_id}")
    assert delete_response.status_code == 204

    # Verify it's gone
    get_response = client.get(f"/calculations/{calc_id}")
    assert get_response.status_code == 404